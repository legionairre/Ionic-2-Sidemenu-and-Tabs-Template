// Ported from 'rollup-plugin-typescript':
// https://github.com/rollup/rollup-plugin-typescript
// MIT Licenced
"use strict";
var tippex = require('tippex');
// The injected id for helpers. Intentially invalid to prevent helpers being included in source maps.
exports.helpersId = '\0typescript-helpers';
exports.helperImports = "import { __assign, __awaiter, __extends, __decorate, __metadata, __param } from '" + exports.helpersId + "';";
exports.helperFns = "\n\nexport const __assign = Object.assign || function (target) {\n    for (var source, i = 1; i < arguments.length; i++) {\n        source = arguments[i];\n        for (var prop in source) {\n            if (Object.prototype.hasOwnProperty.call(source, prop)) {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n};\n\nexport function __extends(d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport function __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __metadata(k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n}\n\nexport function __param(paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments)).next());\n    });\n}\n";
// Hack around TypeScript's broken handling of `export class` with
// ES6 modules and ES5 script target.
//
// It works because TypeScript transforms
//
//     export class A {}
//
// into something like CommonJS, when we wanted ES6 modules.
//
//     var A = (function () {
//         function A() {
//         }
//         return A;
//     }());
//     exports.A = A;
//
// But
//
//     class A {}
//     export { A };
//
// is transformed into this beauty.
//
//     var A = (function () {
//         function A() {
//         }
//         return A;
//     }());
//     export {Â A };
//
// The solution is to replace the previous export syntax with the latter.
function fixExportClass(code, id) {
    // Erase comments, strings etc. to avoid erroneous matches for the Regex.
    var cleanCode = getErasedCode(code, id);
    var re = /export\s+(default\s+)?((?:abstract\s+)?class)(?:\s+(\w+))?/g;
    var match;
    while (match = re.exec(cleanCode)) {
        // To keep source maps intact, replace non-whitespace characters with spaces.
        code = erase(code, match.index, match[0].indexOf(match[2]));
        var name_1 = match[3];
        if (match[1]) {
            // TODO: support this too
            if (!name_1)
                throw new Error("TypeScript Plugin: cannot export an un-named class (module " + id + ")");
            // Export the name ` as default`.
            name_1 += ' as default';
        }
        // To keep source maps intact, append the injected exports last.
        code += "\nexport { " + name_1 + " };";
    }
    return code;
}
exports.fixExportClass = fixExportClass;
function getErasedCode(code, id) {
    try {
        return tippex.erase(code);
    }
    catch (e) {
        throw new Error("rollup-plugin-typescript: " + e.message + "; when processing: '" + id + "'");
    }
}
function erase(code, start, length) {
    var end = start + length;
    return code.slice(0, start) +
        code.slice(start, end).replace(/[^\s]/g, ' ') +
        code.slice(end);
}
