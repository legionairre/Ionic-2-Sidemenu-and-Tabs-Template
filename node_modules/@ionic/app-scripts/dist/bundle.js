"use strict";
var helpers_1 = require('./util/helpers');
var config_1 = require('./util/config');
var ion_compiler_1 = require('./plugins/ion-compiler');
var path_1 = require('path');
var logger_1 = require('./util/logger');
var fs_extra_1 = require('fs-extra');
var os_1 = require('os');
function bundle(context, options, rollupConfig, useCache) {
    if (useCache === void 0) { useCache = true; }
    context = config_1.generateContext(context);
    options = config_1.generateBuildOptions(options);
    var logger = new logger_1.Logger("bundle " + (options.isProd ? 'prod' : 'dev'));
    // bundle the app then create create css
    return runBundle(context, options, rollupConfig, useCache).then(function () {
        return logger.finish();
    }).catch(function (err) {
        logger.fail(err);
        return Promise.reject(err);
    });
}
exports.bundle = bundle;
function bundleUpdate(event, path, context, options, useCache) {
    if (useCache === void 0) { useCache = true; }
    var logger = new logger_1.Logger("bundle " + (options.isProd ? 'prod' : 'dev') + " update");
    logger_1.Logger.debug("bundleUpdate, event: " + event + ", path: " + path);
    return runBundle(context, options, null, useCache).then(function () {
        return logger.finish();
    }).catch(function (err) {
        logger.fail(err);
        return Promise.reject(err);
    });
}
exports.bundleUpdate = bundleUpdate;
function runBundle(context, options, rollupConfig, useCache) {
    rollupConfig = config_1.fillConfigDefaults(context, rollupConfig, ROLLUP_TASK_INFO);
    if (!path_1.isAbsolute(rollupConfig.dest)) {
        // user can pass in absolute paths
        // otherwise save it in the build directory
        rollupConfig.dest = path_1.join(context.buildDir, rollupConfig.dest);
    }
    // replace any path vars like {{TMP}} with the real path
    rollupConfig.entry = config_1.replacePathVars(context, rollupConfig.entry);
    rollupConfig.dest = config_1.replacePathVars(context, rollupConfig.dest);
    if (!options.isProd) {
        // ngc does full production builds itself and the bundler
        // will already have receive transpiled and AoT templates
        // dev mode auto-adds the ion-compiler plugin, which will inline
        // templates and transpile source typescript code to JS before bundling
        rollupConfig.plugins.unshift(ion_compiler_1.default({
            rootDir: context.rootDir,
            sourceMap: rollupConfig.sourceMap
        }));
    }
    if (useCache) {
        // tell rollup to use a previous bundle as its starting point
        rollupConfig.cache = bundleCache;
    }
    if (!rollupConfig.onwarn) {
        // use our own logger if one wasn't already provided
        rollupConfig.onwarn = createOnWarnFn();
    }
    logger_1.Logger.debug("entry: " + rollupConfig.entry + ", dest: " + rollupConfig.dest + ", cache: " + rollupConfig.cache + ", format: " + rollupConfig.format);
    checkDeprecations(options, rollupConfig);
    // bundle the app then create create css
    var rollup = require('rollup').rollup;
    return rollup(rollupConfig).then(function (bundle) {
        logger_1.Logger.debug("bundle.modules: " + bundle.modules.length);
        // set the module files used in this bundle
        // this reference can be used elsewhere in the build (sass)
        context.moduleFiles = bundle.modules.map(function (m) { return m.id; });
        // async cache all the module paths so we don't need
        // to always bundle to know which modules are used
        setModulePathsCache(context.moduleFiles);
        // cache our bundle for later use
        bundleCache = bundle;
        // clean up any references
        rollupConfig.cache = rollupConfig.onwarn = rollupConfig.plugins = null;
        // write the bundle
        return bundle.write(rollupConfig);
    }).catch(function (err) {
        // ensure references are cleared up when there's an error
        bundleCache = rollupConfig.cache = rollupConfig.onwarn = rollupConfig.plugins = null;
        return Promise.reject(err);
    });
}
function checkDeprecations(options, rollupConfig) {
    if (!options.isProd) {
        if (rollupConfig.entry.indexOf('.tmp') > -1 || helpers_1.endsWith(rollupConfig.entry, '.js')) {
            // warning added 2016-10-05, v0.0.29
            throw new Error('\nDev builds no longer use the ".tmp" directory. Please update your rollup config\'s\n' +
                'entry to use your "src" directory\'s "main.dev.ts" TypeScript file.\n' +
                'For example, the entry for dev builds should be: "src/app/main.dev.ts"');
        }
    }
}
function getModulePathsCache() {
    // sync get the cached array of module paths (if they exist)
    var modulePaths = null;
    var modulesCachePath = getModulesPathsCachePath();
    try {
        modulePaths = fs_extra_1.readJsonSync(modulesCachePath, { throws: false });
        logger_1.Logger.debug("Cached module paths: " + (modulePaths && modulePaths.length) + ", " + modulesCachePath);
    }
    catch (e) {
        logger_1.Logger.debug("Cached module paths not found: " + modulesCachePath);
    }
    return modulePaths;
}
exports.getModulePathsCache = getModulePathsCache;
function setModulePathsCache(modulePaths) {
    // async save the module paths for later lookup
    var modulesCachePath = getModulesPathsCachePath();
    logger_1.Logger.debug("Cached module paths: " + (modulePaths && modulePaths.length) + ", " + modulesCachePath);
    fs_extra_1.outputJson(modulesCachePath, modulePaths, function (err) {
        if (err) {
            logger_1.Logger.error("Error writing module paths cache: " + err);
        }
    });
}
function getModulesPathsCachePath() {
    // make a unique tmp directory for this project's module paths cache file
    var cwd = process.cwd().replace(/-|:|\/|\\|\.|~|;|\s/g, '').toLowerCase();
    if (cwd.length > 40) {
        cwd = cwd.substr(cwd.length - 40);
    }
    return path_1.join(os_1.tmpdir(), cwd, 'modulepaths.json');
}
// used to track the cache for subsequent bundles
var bundleCache = null;
function clearCachedModule(id) {
    if (bundleCache) {
        var cachedModule = bundleCache.modules.find(function (m) { return m.id === id; });
        if (cachedModule) {
            var index = bundleCache.modules.indexOf(cachedModule);
            if (index > -1) {
                bundleCache.modules.splice(index, 1);
                logger_1.Logger.debug("clearCachedModule: " + id);
                return true;
            }
        }
    }
    logger_1.Logger.debug("clearCachedModule: no existing bundleCache to clear");
    return false;
}
exports.clearCachedModule = clearCachedModule;
function createOnWarnFn() {
    var previousWarns = {};
    return function onWarningMessage(msg) {
        if (msg in previousWarns) {
            return;
        }
        previousWarns[msg] = true;
        if (!(IGNORE_WARNS.some(function (warnIgnore) { return msg.indexOf(warnIgnore) > -1; }))) {
            logger_1.Logger.warn("rollup: " + msg);
        }
    };
}
var IGNORE_WARNS = [
    'keyword is equivalent to'
];
var ROLLUP_TASK_INFO = {
    fullArgConfig: '--rollup',
    shortArgConfig: '-r',
    envConfig: 'ionic_rollup',
    defaultConfigFilename: 'rollup.config'
};
