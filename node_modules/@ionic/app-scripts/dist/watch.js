"use strict";
var build_1 = require('./build');
var config_1 = require('./util/config');
var logger_1 = require('./util/logger');
var chokidar = require('chokidar');
// https://github.com/paulmillr/chokidar
function watch(context, options, watchConfig) {
    context = config_1.generateContext(context);
    options = config_1.generateBuildOptions(options);
    watchConfig = config_1.fillConfigDefaults(context, watchConfig, WATCH_TASK_INFO);
    // force watch options
    options.isProd = false;
    options.isWatch = true;
    var logger = new logger_1.Logger('watch');
    return build_1.build(context, options).then(function () {
        return startWatchers(context, options, watchConfig).then(function () {
            return logger.ready();
        });
    }).catch(function (err) {
        return logger.fail(err);
    });
}
exports.watch = watch;
function startWatchers(context, options, watchConfig) {
    var promises = watchConfig
        .watchers
        .filter(function (w) { return w.callback && w.paths; })
        .map(function (w) { return startWatcher(w, context, options, watchConfig); });
    return Promise.all(promises);
}
function startWatcher(watcher, context, options, watchConfig) {
    return new Promise(function (resolve, reject) {
        var taskPromise = Promise.resolve();
        var nextTask = null;
        var watcherOptions = watcher.options || {};
        if (!watcherOptions.cwd) {
            watcherOptions.cwd = context.rootDir;
        }
        if (typeof watcherOptions.ignoreInitial !== 'boolean') {
            watcherOptions.ignoreInitial = true;
        }
        var paths = cleanPaths(context, watcher.paths);
        var chokidarWatcher = chokidar.watch(paths, watcherOptions);
        chokidarWatcher.on('all', function (event, path) {
            config_1.setIonicEnvironment(options.isProd);
            logger_1.Logger.debug("watch callback start, id: " + watchCount + ", isProd: " + options.isProd + ", event: " + event + ", path: " + path);
            nextTask = watcher.callback.bind(null, event, path, context, options);
            taskPromise.then(function () {
                logger_1.Logger.debug("watch callback complete, id: " + watchCount + ", isProd: " + options.isProd + ", event: " + event + ", path: " + path);
                taskPromise = nextTask();
                nextTask = null;
                watchCount++;
            }).catch(function (err) {
                logger_1.Logger.debug("watch callback error, id: " + watchCount + ", isProd: " + options.isProd + ", event: " + event + ", path: " + path);
                logger_1.Logger.debug("" + err);
                taskPromise = nextTask();
                nextTask = null;
                watchCount++;
            });
        });
        chokidarWatcher.on('ready', function () {
            logger_1.Logger.debug("watcher ready: " + watcherOptions.cwd + paths);
            resolve();
        });
        chokidarWatcher.on('error', function (err) {
            logger_1.Logger.error("watcher error: " + watcherOptions.cwd + paths + ": " + err);
            reject();
        });
    });
}
function cleanPaths(context, paths) {
    if (Array.isArray(paths)) {
        return paths.map(function (p) { return config_1.replacePathVars(context, p); });
    }
    if (typeof paths === 'string') {
        return config_1.replacePathVars(context, paths);
    }
    return paths;
}
var WATCH_TASK_INFO = {
    fullArgConfig: '--watch',
    shortArgConfig: '-w',
    envConfig: 'ionic_watch',
    defaultConfigFilename: 'watch.config'
};
var watchCount = 0;
