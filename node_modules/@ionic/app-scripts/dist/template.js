"use strict";
var bundle_1 = require('./bundle');
var path_1 = require('path');
var helpers_1 = require('./util/helpers');
var logger_1 = require('./util/logger');
var fs_1 = require('fs');
var sass_1 = require('./sass');
var MagicString = require('magic-string');
function templateUpdate(event, path, context, options) {
    path = path_1.join(context.rootDir, path);
    var logger = new logger_1.Logger('templateUpdate');
    return runTemplateUpdate(event, path, context, options).then(function () {
        // congrats, we did it!
        return logger.finish();
    }).catch(function (err) {
        logger.fail(err);
        return Promise.reject(err);
    });
}
exports.templateUpdate = templateUpdate;
function runTemplateUpdate(event, path, context, options) {
    logger_1.Logger.debug("templateUpdate, event: " + event + ", path: " + path);
    if (event === 'change') {
        // just a change event, see if this html file has a component in the same directory
        // doing this to prevent an unnecessary TS compile and bundling without cache if it was just a HTML change
        var componentFile = getSourceComponentFile(path, context);
        if (bundle_1.clearCachedModule(componentFile)) {
            // we successfully found the compiled JS file and cleared it from the bundle cache
            return bundle_1.bundleUpdate(event, path, context, options, true);
        }
    }
    // not sure how it changed, just do a full rebuild without the bundle cache
    return bundle_1.bundleUpdate(event, path, context, options, false).then(function () {
        return sass_1.sassUpdate(event, path, context, options, true);
    });
}
function getSourceComponentFile(htmlFilePath, context) {
    var rtn = null;
    try {
        var changedHtmlFilename = path_1.basename(htmlFilePath);
        var componentDir = path_1.dirname(htmlFilePath);
        var filePaths = fs_1.readdirSync(componentDir);
        var match = void 0;
        for (var i = 0; i < filePaths.length; i++) {
            var filePath = filePaths[i];
            if (helpers_1.endsWith(filePath, '.ts') && !helpers_1.endsWith(filePath, '.d.ts')) {
                // found a .ts file in this same directory
                // open it up and see if it's a component
                // and see if it has a template url with the same filename
                var tsComponentFile = path_1.join(componentDir, filePath);
                var source = fs_1.readFileSync(path_1.join(componentDir, filePath)).toString();
                if (match = getTemplateMatch(source)) {
                    var componentHtmlFilename = path_1.basename(match.templateUrl);
                    if (changedHtmlFilename === componentHtmlFilename) {
                        rtn = tsComponentFile;
                        break;
                    }
                }
            }
        }
    }
    catch (e) {
        logger_1.Logger.error(e);
    }
    return rtn;
}
function inlineTemplate(sourceText, sourcePath) {
    var magicString = new MagicString(sourceText);
    var componentDir = path_1.parse(sourcePath).dir;
    var match;
    var replacement;
    var lastStart = -1;
    while (match = getTemplateMatch(magicString.toString())) {
        if (match.start === lastStart) {
            // panic! we don't want to melt any machines if there's a bug
            logger_1.Logger.debug("Error matching component: " + match.component);
            return magicString.toString();
        }
        lastStart = match.start;
        if (match.templateUrl === '') {
            logger_1.Logger.error("Error @Component templateUrl missing in: \"" + sourcePath + "\"");
            return magicString.toString();
        }
        replacement = updateTemplate(componentDir, match);
        if (replacement) {
            magicString.overwrite(match.start, match.end, replacement);
        }
    }
    return magicString.toString();
}
exports.inlineTemplate = inlineTemplate;
function updateTemplate(componentDir, match) {
    var templateContent = getTemplateContent(componentDir, match.templateUrl);
    if (!templateContent) {
        return null;
    }
    return replaceTemplateUrl(match, templateContent);
}
function replaceTemplateUrl(match, templateContent) {
    // turn the template into one line and espcape single quotes
    templateContent = templateContent.replace(/\r|\n/g, '\\n');
    templateContent = templateContent.replace(/\'/g, '\\\'');
    var orgTemplateProperty = match.templateProperty;
    var newTemplateProperty = 'template: /* ion-inline-template */ \'' + templateContent + '\'';
    return match.component.replace(orgTemplateProperty, newTemplateProperty);
}
exports.replaceTemplateUrl = replaceTemplateUrl;
function getTemplateContent(componentDir, templateUrl) {
    var rtn = null;
    try {
        rtn = fs_1.readFileSync(path_1.join(componentDir, templateUrl), 'utf-8');
    }
    catch (e) {
        logger_1.Logger.error("Error reading template file, \"" + templateUrl + "\": " + e);
    }
    return rtn;
}
function getTemplateMatch(str) {
    var match = COMPONENT_REGEX.exec(str);
    if (match) {
        return {
            start: match.index,
            end: match.index + match[0].length,
            component: match[0],
            templateProperty: match[3],
            templateUrl: match[5].trim()
        };
    }
    return null;
}
exports.getTemplateMatch = getTemplateMatch;
var COMPONENT_REGEX = /@Component\s*?\(\s*?(\{([\s\S]*?)(\s*templateUrl\s*:\s*(['"`])(.*?)(['"`])\s*?)([\s\S]*?)}\s*?)\)/m;
