// Ported from 'rollup-plugin-typescript':
// https://github.com/rollup/rollup-plugin-typescript
// MIT Licenced
"use strict";
var helpers_1 = require('./util/helpers');
var typescript_helpers_1 = require('./util/typescript-helpers');
var path_1 = require('path');
var logger_1 = require('./util/logger');
var fs_1 = require('fs');
var ts = require('typescript');
function transpile(sourceText, sourcePath, compilerOptions, reportDiagnostics) {
    logger_1.Logger.debug("transpile: " + sourcePath);
    if (sourceText.indexOf(ION_COMPILER_COMMENT) > -1) {
        logger_1.Logger.debug("file already transpiled: " + sourcePath);
        return null;
    }
    var transformed = ts.transpileModule(typescript_helpers_1.fixExportClass(sourceText, sourcePath), {
        fileName: sourcePath,
        reportDiagnostics: reportDiagnostics,
        compilerOptions: compilerOptions
    });
    // All errors except `Cannot compile modules into 'es6' when targeting 'ES5' or lower.`
    var diagnostics = transformed.diagnostics ? transformed.diagnostics.filter(function (diagnostic) { return diagnostic.code !== 1204; }) : [];
    var fatalError = false;
    diagnostics.forEach(function (diagnostic) {
        var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
        if (diagnostic.file) {
            var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
            logger_1.Logger.error(diagnostic.file.fileName + "(" + (line + 1) + "," + (character + 1) + "): error TS" + diagnostic.code + ": " + message);
        }
        else {
            logger_1.Logger.error("Error: " + message);
        }
        if (diagnostic.category === ts.DiagnosticCategory.Error) {
            fatalError = true;
        }
    });
    if (fatalError) {
        throw new Error("There were TypeScript errors transpiling");
    }
    return {
        // always append an import for the helpers
        code: ION_COMPILER_COMMENT + '\n' +
            transformed.outputText + '\n' +
            typescript_helpers_1.helperImports,
        // rollup expects `map` to be an object so we must parse the string
        map: transformed.sourceMapText ? JSON.parse(transformed.sourceMapText) : null
    };
}
exports.transpile = transpile;
function resolveId(importee, importer, compilerOptions) {
    // Handle the special `typescript-helpers` import itself.
    if (importee === typescript_helpers_1.helpersId) {
        return typescript_helpers_1.helpersId;
    }
    if (!importer) {
        return null;
    }
    importer = importer.split('\\').join('/');
    var result = ts.nodeModuleNameResolver(importee, importer, compilerOptions, resolveHost);
    if (result.resolvedModule && result.resolvedModule.resolvedFileName) {
        if (helpers_1.endsWith(result.resolvedModule.resolvedFileName, '.d.ts')) {
            return null;
        }
        return result.resolvedModule.resolvedFileName;
    }
    return null;
}
exports.resolveId = resolveId;
function getTsConfig(rootDir) {
    var config = null;
    var tsConfigPath = path_1.join(rootDir, 'tsconfig.json');
    try {
        var tsConfigFile = ts.readConfigFile(tsConfigPath, function (path) { return fs_1.readFileSync(path, 'utf8'); });
        if (!tsConfigFile) {
            throw new Error("tsconfig error: invalid tsconfig file, \"" + tsConfigPath + "\"");
        }
        else if (tsConfigFile.error && tsConfigFile.error.messageText) {
            throw new Error("tsconfig error: " + tsConfigFile.error.messageText);
        }
        else if (!tsConfigFile.config) {
            throw new Error("tsconfig error: invalid config, \"" + tsConfigPath + "\"\"");
        }
        else if (!tsConfigFile.config.compilerOptions) {
            throw new Error("tsconfig error: invalid compilerOptions, \"" + tsConfigPath + "\"\"");
        }
        else {
            config = tsConfigFile.config;
            setCompilerOptionDefaults(config.compilerOptions);
        }
    }
    catch (e) {
        throw new Error("tsconfig error: error reading tsconfig file \"" + tsConfigPath + "\", " + e);
    }
    return config;
}
exports.getTsConfig = getTsConfig;
function getCompilerOptions(rootDir) {
    var config = getTsConfig(rootDir);
    if (config && config.compilerOptions) {
        // convert to typescripts actual typed compiler options
        var tsCompilerOptions = helpers_1.objectAssign({}, config.compilerOptions);
        if (config.compilerOptions.module === 'es2015' || config.compilerOptions.module === 'es6') {
            tsCompilerOptions.module = ts.ModuleKind.ES2015;
        }
        else if (config.compilerOptions.module === 'commonjs') {
            tsCompilerOptions.module = ts.ModuleKind.CommonJS;
        }
        if (config.compilerOptions.target === 'es5') {
            tsCompilerOptions.target = ts.ScriptTarget.ES5;
        }
        else if (config.compilerOptions.target === 'es6' || config.compilerOptions.target === 'es2015') {
            tsCompilerOptions.target = ts.ScriptTarget.ES2015;
        }
        else if (config.compilerOptions.target === 'latest') {
            tsCompilerOptions.target = ts.ScriptTarget.Latest;
        }
        return tsCompilerOptions;
    }
    return null;
}
exports.getCompilerOptions = getCompilerOptions;
function setCompilerOptionDefaults(compilerOptions) {
    compilerOptions.target = 'es5';
    compilerOptions.module = 'es2015';
}
var resolveHost = {
    directoryExists: function (dirPath) {
        try {
            return fs_1.statSync(dirPath).isDirectory();
        }
        catch (err) {
            return false;
        }
    },
    fileExists: function (filePath) {
        try {
            return fs_1.statSync(filePath).isFile();
        }
        catch (err) {
            return false;
        }
    }
};
var ION_COMPILER_COMMENT = '/* ion-compiler */';
