import { SlideEdgeGesture } from '../../gestures/slide-edge-gesture';
import { assign } from '../../util/util';
export class MenuContentGesture extends SlideEdgeGesture {
    constructor(menu, contentEle, options = {}) {
        super(contentEle, assign({
            direction: 'x',
            edge: menu.side,
            threshold: 0,
            maxEdgeStart: menu.maxEdgeStart || 50,
            maxAngle: 40,
            gesture: menu.gestureCtrl.create('menu-swipe', {
                priority: 10,
            })
        }, options));
        this.menu = menu;
    }
    canStart(ev) {
        let menu = this.menu;
        if (!menu.canSwipe()) {
            return false;
        }
        if (menu.isOpen) {
            return true;
        }
        else if (menu.getMenuController().getOpen()) {
            return false;
        }
        return super.canStart(ev);
    }
    onSlideBeforeStart(ev) {
        // console.debug('menu gesture, onSlideBeforeStart', this.menu.side);
        this.menu.swipeStart();
    }
    onSlide(slide, ev) {
        let z = (this.menu.side === 'right' ? slide.min : slide.max);
        let stepValue = (slide.distance / z);
        // console.debug('menu gesture, onSlide', this.menu.side, 'distance', slide.distance, 'min', slide.min, 'max', slide.max, 'z', z, 'stepValue', stepValue);
        ev.preventDefault();
        this.menu.swipeProgress(stepValue);
    }
    onSlideEnd(slide, ev) {
        let z = (this.menu.side === 'right' ? slide.min : slide.max);
        let currentStepValue = (slide.distance / z);
        let velocity = slide.velocity;
        z = Math.abs(z * 0.5);
        let shouldCompleteRight = (velocity >= 0)
            && (velocity > 0.2 || slide.delta > z);
        let shouldCompleteLeft = (velocity <= 0)
            && (velocity < -0.2 || slide.delta < -z);
        // console.debug('menu gesture, onSlide', this.menu.side);
        // console.debug('distance', slide.distance);
        // console.debug('delta', slide.delta);
        // console.debug('velocity', velocity);
        // console.debug('min', slide.min);
        // console.debug('max', slide.max);
        // console.debug('shouldCompleteLeft', shouldCompleteLeft);
        // console.debug('shouldCompleteRight', shouldCompleteRight);
        // console.debug('currentStepValue', currentStepValue);
        this.menu.swipeEnd(shouldCompleteLeft, shouldCompleteRight, currentStepValue);
    }
    getElementStartPos(slide, ev) {
        if (this.menu.side === 'right') {
            return this.menu.isOpen ? slide.min : slide.max;
        }
        return this.menu.isOpen ? slide.max : slide.min;
    }
    getSlideBoundaries() {
        if (this.menu.side === 'right') {
            return {
                min: -this.menu.width(),
                max: 0
            };
        }
        return {
            min: 0,
            max: this.menu.width()
        };
    }
}
