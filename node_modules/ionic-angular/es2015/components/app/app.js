import { EventEmitter, Injectable } from '@angular/core';
import { Title } from '@angular/platform-browser';
import { Config } from '../../config/config';
import { isNav, isTabs, DIRECTION_FORWARD, DIRECTION_BACK } from '../../navigation/nav-util';
import { Platform } from '../../platform/platform';
export class App {
    constructor(_config, _platform) {
        this._config = _config;
        this._platform = _platform;
        this._disTime = 0;
        this._scrollTime = 0;
        this._title = '';
        this._titleSrv = new Title();
        this._rootNav = null;
        this.viewDidLoad = new EventEmitter();
        this.viewWillEnter = new EventEmitter();
        this.viewDidEnter = new EventEmitter();
        this.viewWillLeave = new EventEmitter();
        this.viewDidLeave = new EventEmitter();
        this.viewWillUnload = new EventEmitter();
        _platform.registerBackButtonAction(this.navPop.bind(this));
    }
    setTitle(val) {
        if (val !== this._title) {
            this._title = val;
            this._titleSrv.setTitle(val);
        }
    }
    setElementClass(className, isAdd) {
        this._appRoot.setElementClass(className, isAdd);
    }
    setEnabled(isEnabled, duration = 700) {
        this._disTime = (isEnabled ? 0 : Date.now() + duration);
        if (this._clickBlock) {
            if (isEnabled || duration <= 32) {
                this._clickBlock.activate(false, 0);
            }
            else {
                this._clickBlock.activate(true, duration + CLICK_BLOCK_BUFFER_IN_MILLIS);
            }
        }
    }
    setScrollDisabled(disableScroll) {
        if (this._config.get('canDisableScroll', true)) {
            this._appRoot._disableScroll(disableScroll);
        }
    }
    isEnabled() {
        return (this._disTime < Date.now());
    }
    setScrolling() {
        this._scrollTime = Date.now();
    }
    isScrolling() {
        return (this._scrollTime + 48 > Date.now());
    }
    getActiveNav() {
        var nav = this._rootNav || null;
        var activeChildNav;
        while (nav) {
            activeChildNav = nav.getActiveChildNav();
            if (!activeChildNav) {
                break;
            }
            nav = activeChildNav;
        }
        return nav;
    }
    getRootNav() {
        return this._rootNav;
    }
    _setRootNav(nav) {
        this._rootNav = nav;
    }
    present(enteringView, opts, appPortal) {
        const portal = this._appRoot._getPortal(appPortal);
        enteringView._setNav(portal);
        opts.keyboardClose = false;
        opts.direction = DIRECTION_FORWARD;
        if (!opts.animation) {
            opts.animation = enteringView.getTransitionName(DIRECTION_FORWARD);
        }
        enteringView.setLeavingOpts({
            keyboardClose: false,
            direction: DIRECTION_BACK,
            animation: enteringView.getTransitionName(DIRECTION_BACK),
            ev: opts.ev
        });
        return portal.insertPages(-1, [enteringView], opts);
    }
    navPop() {
        function navPop(nav) {
            if (nav) {
                if (isTabs(nav)) {
                    let prevTab = nav.previousTab(true);
                    if (prevTab) {
                        // console.debug('app, goBack previous tab');
                        nav.select(prevTab);
                        return Promise.resolve();
                    }
                }
                else if (isNav(nav) && nav.length() > 1) {
                    // console.debug('app, goBack pop nav');
                    return nav.pop();
                }
                return navPop(nav.parent);
            }
            return null;
        }
        if (this._rootNav && this.isEnabled()) {
            const portal = this._appRoot._getPortal();
            if (portal.length() > 0) {
                // console.debug('app, goBack pop overlay');
                return portal.pop();
            }
            let navPromise = navPop(this.getActiveNav());
            if (navPromise === null) {
                if (this._config.getBoolean('navExitApp', true)) {
                    // console.debug('app, goBack exitApp');
                    this._platform.exitApp();
                }
            }
            return navPromise;
        }
        return Promise.resolve();
    }
}
App.decorators = [
    { type: Injectable },
];
App.ctorParameters = [
    { type: Config, },
    { type: Platform, },
];
const CLICK_BLOCK_BUFFER_IN_MILLIS = 64;
